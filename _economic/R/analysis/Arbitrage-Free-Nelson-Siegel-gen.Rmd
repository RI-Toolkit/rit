---
title: "Retirement Income Toolkit - Economic Scenario - AFNS"
author: "Queenie Huang"
output:
 bookdown::html_document2:
    toc: yes
    toc_depth: '4'
    number_sections: yes
    fig_caption: yes
    code_folding: hide
urlcolor: blue
header-includes: |    
 \usepackage{amsmath,amsthm,amssymb,amsfonts, mathtools, empheq, bbm}
 \newcommand{\vect}[1]{\boldsymbol{#1}}
---

```{=html}
<style type="text/css">

body{ /* Normal  */
      font-size: 15px;
  }
td {  /* Table  */
  font-size: 15px;
}
h1.title {
  font-size: 30px;
}
h1 { /* Header 1 */
  font-size: 26px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 15px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 15px;
}
</style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
options(scipen = 1, digits = 6) # use 2 d.p. in output
```

```{r}
library(expm)
library(numDeriv)
library(tidyverse)
library(doParallel)
library(janitor)
library(xts)
library(lubridate)
library(doParallel)
library(pracma)

start_pc_date = as.Date("1993-01-01")
end_date = as.Date("2021-06-01")
optim_ctrl = list(maxit = 5000)

num_year = 10
num_years = 10
num_paths = 100
h = 1/12 # monthly simulations 
time_index_sim = seq(from = end_date, length.out = num_year / h, by = "month")
```

# Import Data

```{r}
#######
# zcp # 
#######

zcp = read.csv("data/zcp.csv")
zcp$date = as.Date(zcp$date)
zcp[,-1] = zcp[,-1] / 100 
zcp = zcp %>% filter(date < end_date & date >= start_pc_date)

# daily data to weekly data
month = as.Date(cut(zcp$date, "month"))
zcp_month = aggregate(. ~ month, zcp, mean)
zcp_month = zcp_month %>% dplyr::select(-date)
dt = 1/12 # monthly

# divide date and data
nf = 3 # 3 state vars 
v.ymd = zcp_month$month
v.mat = seq(from = 3, to = 120, by = 3) / 12
m.spot = as.matrix(zcp_month[,-1])
nmat = length(v.mat) # # of maturities
nobs = nrow(m.spot)  # # of observations

#########
# house # 
#########

properties = read.csv("data/Market_Trends_Data.csv")
properties = clean_names(properties)
properties = properties %>% mutate_if(is.character, as.factor)
properties$value_at_date = as.Date(properties$value_at_date, format =  "%d/%m/%Y")

home_value_houses_nsw = properties %>% 
    filter(state == "NSW", property_type == "Houses") %>% 
    group_by(value_at_date) %>% 
    summarise(index = mean(hedonic_home_value_index, na.rm = T))
home_value_houses_nsw = home_value_houses_nsw %>% 
    filter(value_at_date <= end_date & value_at_date >= start_pc_date) %>% 
    mutate(log_index = log(index))


##########
# ASX200 #
##########

asx200 = read.csv("data/asx200_price.csv")
asx200$exchange_date = as.Date(asx200$exchange_date)
asx200 = asx200 %>% filter(exchange_date <= end_date & exchange_date >= start_pc_date)
asx200$month = format(asx200$exchange_date, "%Y-%m")
asx200 = asx200 %>% group_by(month) %>% summarize(asx200_price = mean(close, na.rm = T)) %>% as.data.frame
asx200$log_price = log(asx200$asx200_price)
```

# Interest Rate Only Arbitrage-Free Nelson-Siegel Model

```{r}
AFNS.C = function(sigma, lambda, tau) {
    # yield-adj term A(t,T) / (T - t) = A(tau) / tau, where tau = (T-t)
    # using the analytical formula on p.7 of Christensen, Diebold (2011)
    s = sigma; la = lambda
    
    s11 = s[1,1]; s12 = s[1,2]; s13 = s[1,3]
    s21 = s[2,1]; s22 = s[2,2]; s23 = s[2,3]
    s31 = s[3,1]; s32 = s[3,2]; s33 = s[3,3]
  
    A = s11^2+s12^2+s13^2; D = s11*s21+s12*s22+s13*s23
    B = s21^2+s22^2+s23^2; E = s11*s31+s12*s32+s13*s33 
    C = s31^2+s32^2+s33^2; F = s21*s31+s22*s32+s23*s33
    
    r1 = A * tau^2 / 6; 
    r2 = B * (1 / (2*la^2) - (1 - exp(-la*tau)) / (la^3 * tau) + (1 - exp(-2*la*tau)) / (4 * la^3 * tau))
    r3 = C * (1 / (2*la^2) + exp(-la*tau) / (la^2) - tau * exp(-2*la*tau) / (4*la) - 3 * exp(-2*la*tau) / (4*la^2) - 2 * (1 - exp(-la*tau)) / (la^3*tau) + 5 * (1 - exp(-2*la*tau)) / (8*la^3*tau))
    r4 = D * (tau / (2*la) + exp(-la*tau) / (la^2) - (1 - exp(-la*tau)) / (la^3*tau))
    r5 = E * (3 * exp(-la*tau) / (la^2) + tau / (2*la) + tau * exp(-la*tau) / (la) - 3 * (1 - exp(-la*tau)) / (la^3*tau))
    r6 = F * (1 / (la^2) + exp(-la*tau) / (la^2) - exp(-2*la*tau) / (2*la^2) - 3 * (1 - exp(-la*tau)) / (la^3*tau) + 3 * (1 - exp(-2*la*tau)) / (4*la^3 * tau))
    
    # returns A(t,T) / (T - t) = A(tau) / tau
    return(r1+r2+r3+r4+r5+r6)
}
```

# Term Structure, Home Value Index, Stock Price AFNS

```{r}
nf = 5 
nmat = 42

NS.B = function(lambda, tau) {
    # the B matrix in the measurement equation 
    col1 = c(rep.int(1,length(tau)),0,0)
    col2 = c((1 - exp(-lambda * tau)) / (lambda * tau),0,0)
    col3 = c(col2[1:length(tau)] - exp(-lambda*tau),0,0)
    col4 = c(rep(0,length(tau)),1,0)
    col5 = c(rep(0,length(tau)),0,1)
    return(cbind(col1,col2,col3,col4,col5))
}

m.spot = cbind(m.spot, home_value_houses_nsw$log_index, asx200$log_price)
```

## Independent Factor

### Estimation

```{r}
# factor estimates
# Xt_gindep_fitted = matrix(0,nobs,nf)
# colnames(Xt_gindep_fitted) = c("level", "slope", "curvature", "house", "stock")
# row.names(Xt_gindep_fitted) = zcp_month$month

trans = function(b) {
    # parameter restrictions of independent factor
    bb = b
    bb[1] = 1/(1+exp(b[1]))  # kappa11
    # bb[4:10] = 1/(1+exp(b[4:10])) # rhos 
    bb[c(4:6,10,15)] = b[c(4:6,10,15)] ^ 2 # sigmas 
    bb[21] = b[21]^2          # lambda
    bb[22:npara] = b[22:npara]^2          # measurement error
    return(bb)
}

##############
# likelihood #
##############

# log likelihood function
loglike = function(para_un, m.spot) {
    # parameter restrictions
    para = trans(para_un)
    
    # restricted parameters (table 1 of Christensen, Diebold (2011))
    kappa  = rbind(c(para[1],0,0,0,0),
                    c(0,para[2],0,0,0),
                    c(0,0,para[3],0,0),
                    c(-1,-1,0,0,0),
                    c(-1,-1,0,0,0))
    sigma  = rbind(c(para[4],0,0,0,0),
                    c(0,para[5],0,0,0),
                    c(0,0,para[6],0,0),
                    c(para[7],para[8],para[9],para[10],0),
                    c(para[11],para[12],para[13],para[14],para[15]))
    theta  = as.matrix(para[16:20])
    lambda = para[21]
    H      = diag(c(rep(para[22],40), para[23:24])) # diag(para[22:npara])
   
    B  = NS.B(lambda,v.mat) # factor loading matrix
    C  = as.matrix(c(-AFNS.C(sigma[1:3,1:3],lambda,v.mat),0,0))    # yield adjustment
  
    # # Conditional and Unconditional covariance matrix : Q, Q0 
    Q_integrand = function(s) { expm(-s * kappa) %*% sigma %*% t(sigma) %*% expm(-s * t(kappa)) }
    xt_term_integrand = function(s) {expm(-s * kappa)}
    integrate_matrix = function (from = 0, to, num_step = 100) {
      results = 0
      step = (to-from)/num_step
      res_step = step
      for (i in seq(from = from+step, to = to, by = step) ) {
        results = results + Q_integrand(res_step)*step 
        res_step = res_step + step 
      }
      return(results)
    }
    integrate_matrix2 = function (from = 0, to, num_step = 100) {
      results = 0
      step = (to-from)/num_step
      res_step = step
      for (i in seq(from = from+step, to = to, by = step) ) {
        results = results + xt_term_integrand(res_step)*step 
        res_step = res_step + step 
      }
      return(results)
    }
    Q = integrate_matrix(from = 0, to = dt, num_step = 10)
    Q0 = integrate_matrix(from = 0, to = 20, num_step = 480)
    xt_term = integrate_matrix2(from = 0, to = dt, num_step = 10)
      
    # initialzation of vector and matrix
    prevX = c(solve(kappa[1:3,1:3]) %*% theta[1:3], home_value_houses_nsw$log_index[1], asx200$log_price[1])
    prevV = Q0
    Phi1  = expm(-kappa * dt)
    Phi0  = xt_term %*% theta
    loglike = 0 # log likelihood function
    
    i = 1
    while (i <= nobs ) {
        Xhat = Phi0 + Phi1 %*% prevX        # predicted state X_{t|t-1}
        Vhat = Phi1 %*% prevV %*% t(Phi1) + Q # predicted cov Sigma_{t|t-1}
        
        y        = m.spot[i,] # the observed yield
        yimplied = B %*% Xhat + C # the model-implied yields
        er       = y - yimplied # prediction error vt
 
        # updating 
        ev = B %*% Vhat %*% t(B) + H # Cov(vt) 
        iev = solve(ev) # inverse 
        KG = Vhat %*% t(B) %*% iev # Kalman Gain
        
        prevX = Xhat + KG %*% er         # E[X|y_t] = Xt updated state 
        prevV = Vhat - KG %*% B %*% Vhat # Cov[X|y_t] updated cov
        
        # log likelihood function
        loglike = loglike - 0.5*(nmat) * log(2*pi)- 0.5*log(det(ev))-0.5 * t(er) %*% iev %*% er
        Xt_gindep_fitted[i,] <<- prevX
        i = i + 1
    }
    
    return(-loglike)
}

##############
# estimation #
##############


load("data/param_gindep.RData")
load("data/Xt_gindep_fitted.RData")
init_para_un = param_gindep$par
npara = length(init_para_un) # # of observations

# cl <- makeCluster(detectCores())
# registerDoParallel(cl)
# param_gindep = optim(init_para_un, loglike,
#           control = optim_ctrl,
#           method = c("Nelder-Mead"), m.spot = m.spot)
# stopCluster(cl)
# init_para_un = param_gindep$par # updating the parameters for next trial 
# save(param_gindep, file = "data/param_gindep.RData") # saving the parameters 
# save(Xt_gindep_fitted, file = "data/Xt_gindep_fitted.RData")
param_gindep$par = trans(param_gindep$par) # imposing constraints to the parameters eg positivity. The model parameters are constrained, but optim() is an unconstrained optimisation algorithm, so the constraints must be incorporated in the objective ie in trans(). 

##########
# fitted #
########## 

kappa_est = rbind(c(param_gindep$par[1],0,0,0,0),
                  c(0,param_gindep$par[2],0,0,0),
                  c(0,0,param_gindep$par[3],0,0),
                  c(-1,-1,0,0,0),
                  c(-1,-1,0,0,0))
Sigma_est = rbind(c(param_gindep$par[4],0,0,0,0),
                  c(0,param_gindep$par[5],0,0,0),
                  c(0,0,param_gindep$par[6],0,0),
                  c(param_gindep$par[7],param_gindep$par[8],param_gindep$par[9],param_gindep$par[10],0),
                  c(param_gindep$par[11],param_gindep$par[12],param_gindep$par[13],param_gindep$par[14],param_gindep$par[15]))
theta_est  = as.matrix(param_gindep$par[16:20])
lambda_est = param_gindep$par[21]

# fitted Xt 
matplot(Xt_gindep_fitted[,1:3], type = "l", ylab = "L,S,C", lty = 1, main = "AFNS 5 Factor Estimates (L,S,C)", lwd = 2)
legend("topright", legend = c("level", "slope", "curvature"), col = 1:3, lty = 1)

# compare fitted yields 
B_gindep_fitted = NS.B(lambda_est, v.mat)
A_gindep_fitted = c(AFNS.C(Sigma_est, lambda_est, v.mat),0,0)
zcp_gindep_fitted = t(B_gindep_fitted %*% t(Xt_gindep_fitted)) - A_gindep_fitted

par(mfrow = c(1,2))
plot(zcp_month$month, zcp_gindep_fitted[,1], "l", main = "Historical vs fitted \n 3-month zero-coupon yields", xlab = "", ylab = "")
lines(zcp_month$month, zcp_month$x1_qtrs, col = "blue")
legend("topright", legend = c("fitted", "historic"), col = c("black", "blue"), lty = 1)

plot(zcp_month$month, zcp_gindep_fitted[,40], "l", main = "Historical vs fitted \n 10-year zero-coupon yields", xlab = "", ylab = "")
lines(zcp_month$month, zcp_month$x40_qtrs, col = "blue")

plot(zcp_month$month, Xt_gindep_fitted[,4], "l", main = "Historical vs fitted \n log NSW House Indexes", xlab = "", ylab = "")
lines(zcp_month$month, m.spot[,41], col = "blue")
legend("topleft", legend = c("fitted", "historic"), col = c("black", "blue"), lty = 1)

plot(zcp_month$month, Xt_gindep_fitted[,5], "l", main = "Historical vs fitted \n log ASX/S&P200 Price", xlab = "", ylab = "")
lines(zcp_month$month, m.spot[,42], col = "blue")
```

### Simulation 

```{r}
###############
# simulate Xt # 
###############

# simulation 
Xt_gindep_sim = replicate(n = num_paths,
                         expr = {data.frame(matrix(NA, nrow = nf, ncol = num_year/h+1))},
                         simplify = F)
Xt_gindep_sim = lapply(Xt_gindep_sim, function (x) {x[,1] = Xt_gindep_fitted[nrow(Xt_gindep_fitted),]; return (x)})

for (path in 1:num_paths) { # discretisation
  for (i in 2:(num_year/h+1)) {
    e = as.matrix(rnorm(nf)) # as.matrix(MASS::mvrnorm(mu = rep(0,5), Sigma = Q)) 
    Xt = as.matrix(Xt_gindep_sim[[path]][,i-1])
    Xt_gindep_sim[[path]][,i] =  Xt + (theta_est - kappa_est %*% Xt) * h + sqrt(h) * Sigma_est %*% e # xt_term %*% theta_est + expm(-h * KP_est) %*% Xt + e 
  }
}

# mean 
Xt_gindep_mean = data.frame(matrix(NA, nrow = nf, ncol = num_year/h+1))
Xt_gindep_mean[,1] = Xt_gindep_fitted[nrow(Xt_gindep_fitted),]
for (i in 2:(num_year/h+1)) {
  Xt = as.matrix(Xt_gindep_mean[,i-1])
  Xt_gindep_mean[,i] = Xt + h * (theta_est - kappa_est %*% Xt) 
}

###########
# plot Xt #
###########
par(mfrow = c(1,3))
plot_date = seq(from = start_pc_date, to = max(time_index_sim), by = "month")

#######
# level
# sim 
plot_data = c(Xt_gindep_fitted[,1], Xt_gindep_sim[[1]][1,-1])
plot(plot_date, plot_data, "l", main = "Simulated Latent Level Factor", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(Xt_gindep_fitted[,1], Xt_gindep_sim[[i]][1,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean 
plot_data = c(Xt_gindep_fitted[,1], Xt_gindep_mean[1,-1])
lines(plot_date, plot_data)

########
# slope
# sim 
plot_data = c(Xt_gindep_fitted[,2], Xt_gindep_sim[[1]][2,-1])
plot(plot_date, plot_data, "l", main = "Simulated Latent Slope Factor", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(Xt_gindep_fitted[,2], Xt_gindep_sim[[i]][2,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean 
plot_data = c(Xt_gindep_fitted[,2], Xt_gindep_mean[2,-1])
lines(plot_date, plot_data)

###########
# curvature
# sim 
plot_data = c(Xt_gindep_fitted[,3], Xt_gindep_sim[[1]][3,-1])
plot(plot_date, plot_data, "l", main = "Simulated Latent Curvature Factor", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(Xt_gindep_fitted[,3], Xt_gindep_sim[[i]][3,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean 
plot_data = c(Xt_gindep_fitted[,3], Xt_gindep_mean[3,-1])
lines(plot_date, plot_data)

par(mfrow = c(1,2))

########
# house
# sim
plot_data = c(m.spot[,41], Xt_gindep_sim[[1]][4,-1])
plot(plot_date, plot_data, "l", main = "Simulated house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(m.spot[,41], Xt_gindep_sim[[i]][4,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(m.spot[,41], Xt_gindep_mean[4,-1])
lines(plot_date, plot_data)

########
# stock
# sim
plot_data = c(m.spot[,42], Xt_gindep_sim[[1]][5,-1])
plot(plot_date, plot_data, "l", main = "Simulated stock prices", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(m.spot[,42], Xt_gindep_sim[[i]][5,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(m.spot[,42], Xt_gindep_mean[5,-1])
lines(plot_date, plot_data)


##############
# compute yt #
##############

# simulations
zcp_gindep_sim = replicate(n = num_paths,
                         expr = {matrix(NA, nrow = num_year/h+1, ncol = 42)},
                         simplify = F)
for (path in 2:num_paths) {
  zcp_gindep_sim[[path]] = t(B_gindep_fitted %*% as.matrix(Xt_gindep_sim[[path]])) - A_gindep_fitted
}
zcp_gindep_sim = lapply(zcp_gindep_sim, function(x){ x = as.data.frame(x); x[1,] = m.spot[nrow(m.spot),]; return (x)})
zcp_gindep_sim = lapply(zcp_gindep_sim, function(x){row.names(x) = c("2021-05-01", as.character(time_index_sim)); colnames(x) = colnames(zcp)[-1]; return (x)})

# mean
zcp_gindep_mean = t(B_gindep_fitted %*% as.matrix(Xt_gindep_mean)) - A_gindep_fitted
zcp_gindep_mean = as.data.frame(zcp_gindep_mean)
row.names(zcp_gindep_mean) = c("2021-05-01", as.character(time_index_sim))
colnames(zcp_gindep_mean) = colnames(zcp)[-1]
zcp_gindep_mean[1,] = zcp_month[nrow(zcp_month),-1]


###########
# plot yt #
###########

#######
# zcp3m
# sim
plot_data = c(zcp_month$x1_qtrs, zcp_gindep_sim[[1]][-1,1])
plot(plot_date, plot_data, "l", main = "Simulated 3-month zero-coupon yields", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x1_qtrs, zcp_gindep_sim[[i]][-1,1])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(zcp_month$x1_qtrs, zcp_gindep_mean[-1,1])
lines(plot_date, plot_data)

########
# zcp10y
# sim
plot_data = c(zcp_month$x40_qtrs, zcp_gindep_sim[[1]][-1,40])
plot(plot_date, plot_data, "l", main = "Simulated 10-year zero-coupon yields", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x40_qtrs, zcp_gindep_sim[[i]][-1,40])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(zcp_month$x40_qtrs, zcp_gindep_mean[-1,40])
lines(plot_date, plot_data)
```

### get_afns_simulation testing 

```{r}
source("../AFNS.R")
source("../Model.R")
par(mfrow = c(2,2))

###########
# monthly # 
###########

cl <- makeCluster(detectCores())
registerDoParallel(cl)
set.seed(1)
zcp_sim = get_afns_simulation(num_years = num_years, num_paths = num_paths, frequency = "month", type = "independent", model = "interest_house_stock")
stopCluster(cl)

# 6-month 
plot_date = c(zcp_month$month, row.names(zcp_sim[[1]]))
plot_data = c(zcp_month$x1_qtrs, zcp_sim$maturity_1qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 3-month zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x1_qtrs, zcp_sim$maturity_1qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# 5-year
plot_data = c(zcp_month$x40_qtrs, zcp_sim$maturity_40qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 10-year zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x40_qtrs, zcp_sim$maturity_40qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# house 
plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,1])
plot(plot_date, plot_data, "l", main = "Simulated house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,i])
  lines(plot_date, plot_data, col = "grey")
}

# stock 
plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,1])
plot(plot_date, plot_data, "l", main = "Simulated stock prices", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,i])
  lines(plot_date, plot_data, col = "grey")
}


#############
# quarterly #
#############

cl <- makeCluster(detectCores())
registerDoParallel(cl)
set.seed(1)
zcp_sim = get_afns_simulation(num_years = num_years, num_paths = num_paths, frequency = "quarter", type = "independent", model = "interest_house_stock")
stopCluster(cl)

# 6-month 
plot_date = c(zcp_month$month, row.names(zcp_sim[[1]]))
plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 6-month zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# 5-year
plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 5-year zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# house 
plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,1])
plot(plot_date, plot_data, "l", main = "Simulated house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,i])
  lines(plot_date, plot_data, col = "grey")
}

# stock 
plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,1])
plot(plot_date, plot_data, "l", main = "Simulated stock prices", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,i])
  lines(plot_date, plot_data, col = "grey")
}

############
# annually #
############

cl <- makeCluster(detectCores())
registerDoParallel(cl)
set.seed(1)
zcp_sim = get_afns_simulation(num_years = num_years, num_paths = num_paths, frequency = "year", type = "independent", model = "interest_house_stock")
stopCluster(cl)

# 6-month 
plot_date = c(zcp_month$month, row.names(zcp_sim[[1]]))
plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 6-month zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# 5-year
plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 5-year zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# house 
plot_data = c(m.spot[,41], log(zcp_sim$house_index[,1]))
plot(plot_date, plot_data, "l", main = "Simulated log house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(m.spot[,41], log(zcp_sim$house_index[,i]))
  lines(plot_date, plot_data, col = "grey")
}

# stock 
plot_data = c(m.spot[,42], log(zcp_sim$stock_price[,1]))
plot(plot_date, plot_data, "l", main = "Simulated log stock prices", xlab = "", ylab = "", col = "grey",)
for (i in 2:num_paths) {
  plot_data = c(m.spot[,42], log(zcp_sim$stock_price[,i]))
  lines(plot_date, plot_data, col = "grey")
}
```



## Correlated Factor

### Estimation

```{r}
# factor estimates
Xt_gcorr_fitted = matrix(0,nobs,nf)
colnames(Xt_gcorr_fitted) = c("level", "slope", "curvature", "house", "stock")
row.names(Xt_gcorr_fitted) = zcp_month$month

trans = function(b) {
    # parameter restrictions of independent factor
    bb = b
    bb[1] = 1/(1+exp(b[1])) # kappa11
    bb[c(10,12,15,19,24)] = b[c(10,12,15,19,24)] ^ 2 # sigmas
    bb[30] = b[30]^2          # lambda
    bb[31:npara] = b[31:npara]^2          # measurement error
    return(bb)
}

##############
# likelihood #
##############

# log likelihood function
loglike = function(para_un, m.spot) {
    # parameter restrictions
    para = trans(para_un)
    
    # restricted parameters (table 1 of Christensen, Diebold (2011))
    kappa  = rbind(c(para[1],para[2],para[3],0,0),
                    c(para[4],para[5],para[6],0,0),
                    c(para[7],para[8],para[9],0,0),
                    c(-1,-1,0,0,0),
                    c(-1,-1,0,0,0))
    # rho41 = para[10]; rho42 = para[11]; rho43 = para[12]
    # rho44 = sqrt(1 - rho41^2 - rho42^2 - rho43^2)
    # rho51 = para[13]; rho52 = para[14]; rho53 = para[15]; rho54 = para[16]
    # rho55 = sqrt(1 - rho51^2 - rho52^2 - rho53^2 - rho54 ^ 2)
    # sigma4 = para[17]; sigma5 = para[18]
    sigma  = rbind(c(para[10],0,0,0,0),
                    c(para[11],para[12],0,0,0),
                    c(para[13],para[14],para[15],0,0),
                    c(para[16],para[17],para[18],para[19],0),
                    c(para[20],para[21],para[22],para[23], para[24]))
    theta  = as.matrix(para[25:29])
    lambda = para[30]
    H      = diag(c(rep(para[31],40),para[32],para[33]))
   
    B  = NS.B(lambda,v.mat) # factor loading matrix
    C  = as.matrix(c(-AFNS.C(sigma[1:3,1:3],lambda,v.mat),0,0))    # yield adjustment
  
    # # Conditional and Unconditional covariance matrix : Q, Q0 
    Q_integrand = function(s) { expm(-s * kappa) %*% sigma %*% t(sigma) %*% expm(-s * t(kappa)) }
    xt_term_integrand = function(s) {expm(-s * kappa)}
    integrate_matrix = function (from = 0, to, num_step = 100) {
      results = 0
      step = (to-from)/num_step
      res_step = step
      for (i in seq(from = from+step, to = to, by = step) ) {
        results = results + Q_integrand(res_step)*step 
        res_step = res_step + step 
      }
      return(results)
    }
    integrate_matrix2 = function (from = 0, to, num_step = 100) {
      results = 0
      step = (to-from)/num_step
      res_step = step
      for (i in seq(from = from+step, to = to, by = step) ) {
        results = results + xt_term_integrand(res_step)*step 
        res_step = res_step + step 
      }
      return(results)
    }
    Q = integrate_matrix(from = 0, to = dt, num_step = 10)
    Q0 = integrate_matrix(from = 0, to = 10, num_step = 240)
    xt_term = integrate_matrix2(from = 0, to = dt, num_step = 10)
      
    # initialzation of vector and matrix
    prevX = c(solve(kappa[1:3,1:3]) %*% theta[1:3], home_value_houses_nsw$log_index[1], asx200$log_price[1])
    prevV = Q0
    Phi1  = expm(-kappa * dt)
    Phi0  = xt_term %*% theta
    loglike = 0 # log likelihood function
    
    i = 1
    while (i <= nobs ) {
        Xhat = Phi0 + Phi1 %*% prevX        # predicted state X_{t|t-1}
        Vhat = Phi1 %*% prevV %*% t(Phi1) + Q # predicted cov Sigma_{t|t-1}
        
        y        = m.spot[i,] # the observed yield
        yimplied = B %*% Xhat + C # the model-implied yields
        er       = y - yimplied # prediction error vt
 
        # updating 
        ev = B %*% Vhat %*% t(B) + H # Cov(vt) 
        iev = solve(ev) # inverse 
        KG = Vhat %*% t(B) %*% iev # Kalman Gain
        
        prevX = Xhat + KG %*% er         # E[X|y_t] = Xt updated state 
        prevV = Vhat - KG %*% B %*% Vhat # Cov[X|y_t] updated cov
        
        # log likelihood function
        loglike = loglike - 0.5*(nmat) * log(2*pi)- 0.5*log(det(ev))-0.5 * t(er) %*% iev %*% er
        Xt_gcorr_fitted[i,] <<- prevX
        i = i + 1
    }
    return(-loglike)
}

##############
# estimation #
##############

load("Xt_gcorr_fitted.RData")
load("param_gcorr_new.RData")
init_para_un = param_gcorr$par
npara = length(init_para_un) # # of observations

# cl <- makeCluster(detectCores())
# registerDoParallel(cl)
# param_gcorr = optim(init_para_un, loglike,
#           control = optim_ctrl,
#           method = c("Nelder-Mead"), m.spot = m.spot)
# stopCluster(cl)
param_gcorr$par = trans(param_gcorr$par)
save(param_gcorr, file = "param_gcorr.RData")
save(Xt_gcorr_fitted, file = "Xt_gcorr_fitted.RData")

##########
# fitted #
########## 

kappa_est = rbind(c(param_gcorr$par[1],param_gcorr$par[2],param_gcorr$par[3],0,0),
                  c(param_gcorr$par[4],param_gcorr$par[5],param_gcorr$par[6],0,0),
                  c(param_gcorr$par[7],param_gcorr$par[8],param_gcorr$par[9],0,0),
                  c(-1,-1,0,0,0),
                  c(-1,-1,0,0,0))
Sigma_est = rbind(c(param_gcorr$par[10],0,0,0,0),
                  c(param_gcorr$par[11],param_gcorr$par[12],0,0,0),
                  c(param_gcorr$par[13],param_gcorr$par[14],param_gcorr$par[15],0,0),
                  c(param_gcorr$par[16],param_gcorr$par[17],param_gcorr$par[18],param_gcorr$par[19],0),
                  c(param_gcorr$par[20],param_gcorr$par[21],param_gcorr$par[22],param_gcorr$par[23],param_gcorr$par[24]))
theta_est  = as.matrix(param_gcorr$par[25:29])
lambda_est = param_gcorr$par[30]

# fitted Xt 
matplot(Xt_gcorr_fitted[,1:3], type = "l", ylab = "L,S,C", lty = 1, main = "AFNS 5 Factor Estimates (L,S,C)", lwd = 2)
legend("topright", legend = c("level", "slope", "curvature"), col = 1:3, lty = 1)

# compare fitted yields 
B_gcorr_fitted = NS.B(lambda_est, v.mat)
A_gcorr_fitted = AFNS.C(Sigma_est, lambda_est, v.mat)
zcp_gcorr_fitted = t(B_gcorr_fitted[1:40,1:3] %*% t(Xt_gcorr_fitted[,1:3])) - A_gcorr_fitted

par(mfrow = c(2,2))
plot(zcp_month$month, zcp_gcorr_fitted[,1], "l", main = "Historical vs fitted \n 3-month zero-coupon yields", xlab = "", ylab = "")
lines(zcp_month$month, zcp_month$x1_qtrs, col = "blue")

plot(zcp_month$month, zcp_gcorr_fitted[,40], "l", main = "Historical vs fitted \n 10-year zero-coupon yields", xlab = "", ylab = "")
lines(zcp_month$month, zcp_month$x40_qtrs, col = "blue")

plot(zcp_month$month, Xt_gcorr_fitted[,4], "l", main = "Historical vs fitted \n log NSW House Indexes", xlab = "", ylab = "")
lines(zcp_month$month, m.spot[,41], col = "blue")

plot(zcp_month$month, Xt_gcorr_fitted[,5], "l", main = "Historical vs fitted \n log ASX/S&P200 Price", xlab = "", ylab = "")
lines(zcp_month$month, m.spot[,42], col = "blue")
```

### Simulation

```{r}
###############
# simulate Xt # 
###############

# simulation 
Xt_gcorr_sim = replicate(n = num_paths,
                         expr = {data.frame(matrix(NA, nrow = nf, ncol = num_year/h+1))},
                         simplify = F)
Xt_gcorr_sim = lapply(Xt_gcorr_sim, function (x) {x[,1] = Xt_gcorr_fitted[nrow(Xt_gcorr_fitted),]; return (x)})

for (path in 1:num_paths) { # discretisation
  for (i in 2:(num_year/h+1)) {
    e = as.matrix(rnorm(nf)) # as.matrix(MASS::mvrnorm(mu = rep(0,5), Sigma = Q)) 
    Xt = as.matrix(Xt_gcorr_sim[[path]][,i-1])
    Xt_gcorr_sim[[path]][,i] =  Xt + (theta_est - kappa_est %*% Xt) * h + sqrt(h) * Sigma_est %*% e # xt_term %*% theta_est + expm(-h * KP_est) %*% Xt + e 
  }
}

# mean 
Xt_gcorr_mean = data.frame(matrix(NA, nrow = nf, ncol = num_year/h+1))
Xt_gcorr_mean[,1] = Xt_gcorr_fitted[nrow(Xt_gcorr_fitted),]
for (i in 2:(num_year/h+1)) {
  Xt = as.matrix(Xt_gcorr_mean[,i-1])
  Xt_gcorr_mean[,i] = Xt + h * (theta_est - kappa_est %*% Xt) 
}

###########
# plot Xt #
###########
par(mfrow = c(1,3))
plot_date = seq(from = start_pc_date, to = max(time_index_sim), by = "month")

#######
# level
# sim 
plot_data = c(Xt_gcorr_fitted[,1], Xt_gcorr_sim[[1]][1,-1])
plot(plot_date, plot_data, "l", main = "Simulated Latent Level Factor", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(Xt_gcorr_fitted[,1], Xt_gcorr_sim[[i]][1,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean 
plot_data = c(Xt_gcorr_fitted[,1], Xt_gcorr_mean[1,-1])
lines(plot_date, plot_data)

########
# slope
# sim 
plot_data = c(Xt_gcorr_fitted[,2], Xt_gcorr_sim[[1]][2,-1])
plot(plot_date, plot_data, "l", main = "Simulated Latent Slope Factor", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(Xt_gcorr_fitted[,2], Xt_gcorr_sim[[i]][2,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean 
plot_data = c(Xt_gcorr_fitted[,2], Xt_gcorr_mean[2,-1])
lines(plot_date, plot_data)

###########
# curvature
# sim 
plot_data = c(Xt_gcorr_fitted[,3], Xt_gcorr_sim[[1]][3,-1])
plot(plot_date, plot_data, "l", main = "Simulated Latent Curvature Factor", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(Xt_gcorr_fitted[,3], Xt_gcorr_sim[[i]][3,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean 
plot_data = c(Xt_gcorr_fitted[,3], Xt_gcorr_mean[3,-1])
lines(plot_date, plot_data)

par(mfrow = c(1,2))

########
# house
# sim
plot_data = c(m.spot[,41], Xt_gcorr_sim[[1]][4,-1])
plot(plot_date, plot_data, "l", main = "Simulated house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(m.spot[,41], Xt_gcorr_sim[[i]][4,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(m.spot[,41], Xt_gcorr_mean[4,-1])
lines(plot_date, plot_data)

########
# stock
# sim
plot_data = c(m.spot[,42], Xt_gcorr_sim[[1]][5,-1])
plot(plot_date, plot_data, "l", main = "Simulated stock prices", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(m.spot[,42], Xt_gcorr_sim[[i]][5,-1])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(m.spot[,42], Xt_gcorr_mean[5,-1])
lines(plot_date, plot_data)


##############
# compute yt #
##############

# simulations
zcp_gcorr_sim = replicate(n = num_paths,
                         expr = {matrix(NA, nrow = num_year/h+1, ncol = 42)},
                         simplify = F)
for (path in 2:num_paths) {
  zcp_gcorr_sim[[path]] = t(B_gcorr_fitted %*% as.matrix(Xt_gcorr_sim[[path]])) - A_gcorr_fitted
}
zcp_gcorr_sim = lapply(zcp_gcorr_sim, function(x){ x = as.data.frame(x); x[1,] = m.spot[nrow(m.spot),]; return (x)})
zcp_gcorr_sim = lapply(zcp_gcorr_sim, function(x){row.names(x) = c("2021-05-01", as.character(time_index_sim)); colnames(x) = colnames(zcp)[-1]; return (x)})

# mean
zcp_gcorr_mean = t(B_gcorr_fitted %*% as.matrix(Xt_gcorr_mean)) - A_gcorr_fitted
zcp_gcorr_mean = as.data.frame(zcp_gcorr_mean)
row.names(zcp_gcorr_mean) = c("2021-05-01", as.character(time_index_sim))
colnames(zcp_gcorr_mean) = colnames(zcp)[-1]
zcp_gcorr_mean[1,] = zcp_month[nrow(zcp_month),-1]


###########
# plot yt #
###########

#######
# zcp3m
# sim
plot_data = c(zcp_month$x1_qtrs, zcp_gcorr_sim[[1]][-1,1])
plot(plot_date, plot_data, "l", main = "Simulated 3-month zero-coupon yields", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x1_qtrs, zcp_gcorr_sim[[i]][-1,1])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(zcp_month$x1_qtrs, zcp_gcorr_mean[-1,1])
lines(plot_date, plot_data)

########
# zcp10y
# sim
plot_data = c(zcp_month$x40_qtrs, zcp_gcorr_sim[[1]][-1,40])
plot(plot_date, plot_data, "l", main = "Simulated 10-year zero-coupon yields", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x40_qtrs, zcp_gcorr_sim[[i]][-1,40])
  lines(plot_date, plot_data, col = "grey")
}
# mean
plot_data = c(zcp_month$x40_qtrs, zcp_gcorr_mean[-1,40])
lines(plot_date, plot_data)
```

### get_gafns_simulation 

```{r}
source("../AFNS.R")
source("../Model.R")
par(mfrow = c(2,2))

###########
# monthly # 
###########

cl <- makeCluster(detectCores())
registerDoParallel(cl)
set.seed(1)
zcp_sim = get_afns_simulation(num_years = num_years, num_paths = num_paths, frequency = "month", type = "correlated", model = "interest_house_stock")
stopCluster(cl)

# 6-month 
plot_date = c(zcp_month$month, row.names(zcp_sim[[1]]))
plot_data = c(zcp_month$x1_qtrs, zcp_sim$maturity_1qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 3-month zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x1_qtrs, zcp_sim$maturity_1qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# 5-year
plot_data = c(zcp_month$x40_qtrs, zcp_sim$maturity_40qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 10-year zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x40_qtrs, zcp_sim$maturity_40qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# house 
plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,1])
plot(plot_date, plot_data, "l", main = "Simulated house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,i])
  lines(plot_date, plot_data, col = "grey")
}

# stock 
plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,1])
plot(plot_date, plot_data, "l", main = "Simulated stock prices", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,i])
  lines(plot_date, plot_data, col = "grey")
}


#############
# quarterly #
#############

cl <- makeCluster(detectCores())
registerDoParallel(cl)
set.seed(1)
zcp_sim = get_afns_simulation(num_years = num_years, num_paths = num_paths, frequency = "quarter", type = "correlated", model = "interest_house_stock")
stopCluster(cl)

# 6-month 
plot_date = c(zcp_month$month, row.names(zcp_sim[[1]]))
plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 6-month zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# 5-year
plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 5-year zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# house 
plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,1])
plot(plot_date, plot_data, "l", main = "Simulated house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,i])
  lines(plot_date, plot_data, col = "grey")
}

# stock 
plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,1])
plot(plot_date, plot_data, "l", main = "Simulated stock prices", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,i])
  lines(plot_date, plot_data, col = "grey")
}

############
# annually #
############

cl <- makeCluster(detectCores())
registerDoParallel(cl)
set.seed(1)
zcp_sim = get_afns_simulation(num_years = num_years, num_paths = num_paths, frequency = "year", type = "correlated", model = "interest_house_stock")
stopCluster(cl)

# 6-month 
plot_date = c(zcp_month$month, row.names(zcp_sim[[1]]))
plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 6-month zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x2_qtrs, zcp_sim$maturity_2qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# 5-year
plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,1])
plot(plot_date, plot_data, "l", main = "Simulated 5-year zero-coupon yields", xlab = "", ylab = "", col = "grey", ylim = c(-0.04,0.1))
for (i in 2:num_paths) {
  plot_data = c(zcp_month$x20_qtrs, zcp_sim$maturity_20qtrs[,i])
  lines(plot_date, plot_data, col = "grey")
}

# house 
plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,1])
plot(plot_date, plot_data, "l", main = "Simulated house indexes", xlab = "", ylab = "", col = "grey")
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,41]), zcp_sim$house_index[,i])
  lines(plot_date, plot_data, col = "grey")
}

# stock 
plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,1])
plot(plot_date, plot_data, "l", main = "Simulated stock prices", xlab = "", ylab = "", col = "grey",)
for (i in 2:num_paths) {
  plot_data = c(exp(m.spot[,42]), zcp_sim$stock_price[,i])
  lines(plot_date, plot_data, col = "grey")
}
```
